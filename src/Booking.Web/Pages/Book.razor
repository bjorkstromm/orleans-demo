@page "/book"
@implements IAsyncDisposable
@implements IRoomObserver
@using System.ComponentModel.DataAnnotations
@using Blazored.Toast.Services
@inject IClusterClient ClusterClient
@inject IToastService ToastService

<PageTitle>Book</PageTitle>

<h1>Book</h1>

@if (_rooms == null)
{
    <p>
        <em>Loading...</em>
    </p>
}
else
{
    <EditForm Model="@_inputModel" OnValidSubmit="@FetchTimeSlots">
        <DataAnnotationsValidator />

        <div class="row">
            <div class="col">
                <select class="form-select"
                        @bind="_inputModel.RoomId">
                    @foreach (var room in _rooms)
                    {
                        <option value="@room.Id">@room.Name</option>
                    }
                </select>
            </div>

            <div class="col">
                <input class="form-control" type="date" @bind="_inputModel.Date" @bind:format="yyyy-MM-dd">
            </div>

            <div class="col">
                <button class="btn btn-primary" type="submit">Select</button>
            </div>
        </div>
    </EditForm>

    <hr/>

    <table class="table table-striped">
        <thead>
        <tr>
            <th>Date</th>
            <th>Start</th>
            <th>Stop</th>
            <th>Available</th>
        </tr>
        </thead>
        <tbody>
        @foreach (var timeSlot in _timeSlots)
        {
            <tr @onclick="() => Reserve(timeSlot.Id)"
                class="clickable"
                style="@(timeSlot.Available ? "" : "background-color: red")">
                <td>@timeSlot.Date</td>
                <td>@timeSlot.Start</td>
                <td>@timeSlot.End</td>
                <td>@timeSlot.Available</td>
            </tr>
        }
        </tbody>
    </table>

    <hr/>

    @if (_reservation is not null)
    {
        if (_reservation.Success)
        {
            var expiresIn = Math.Max(0, (int)(_reservation.ExpiresOn!.Value - DateTimeOffset.UtcNow).TotalSeconds);

            <p>Reservation expires in @(expiresIn) seconds.</p>
            <button class="btn btn-danger" type="submit" onclick="@CancelReservation">Cancel</button>
            <button class="btn btn-primary" type="submit" onclick="@CompleteBooking">Book</button>
        }
        else
        {
            <p style="color: red">Reservation failed.</p>
        }
    }
}

@code {

    public class InputModel
    {
        [Required]
        public string? RoomId { get; set; }

        public DateTime Date { get; set; } = DateTime.Today;
    }

    private IReadOnlyCollection<Room>? _rooms;
    private IReadOnlyCollection<TimeSlot> _timeSlots = Array.Empty<TimeSlot>();

    private readonly InputModel _inputModel = new();
    private Reservation? _reservation;
    private Timer? _reservationTimer;

    private volatile string? _observedRoomId;
    private Timer? _roomObserverTimer;

    protected override async Task OnInitializedAsync()
    {
        using var _ = ActivityScope.Create(nameof(OnInitializedAsync));

        _roomObserverTimer = new Timer(ResubscribeToRoom,  null, 0, 5000);

        var catalog = ClusterClient.GetGrain<IRoomCatalogGrain>(0);
        _rooms = await catalog.GetRooms();
        _inputModel.RoomId = _rooms.FirstOrDefault()?.Id;

        await FetchTimeSlots();
    }

    private async Task FetchTimeSlots()
    {
        using var _ = ActivityScope.Create(nameof(FetchTimeSlots));

        var room = ClusterClient.GetGrain<IRoomGrain>(_inputModel.RoomId);

        _timeSlots = await room.GetTimeSlots(DateOnly.FromDateTime(_inputModel.Date));

        // Observe changes to the room.
        var observer = ClusterClient.CreateObjectReference<IRoomObserver>(this);
        await room.Subscribe(observer);

        // Remember the observed room.
        var oldObserverRoomId = _observedRoomId;
        _observedRoomId = _inputModel.RoomId;

        // Unsubscribe from the previous room.
        if (oldObserverRoomId is not null && oldObserverRoomId != _inputModel.RoomId)
        {
            room = ClusterClient.GetGrain<IRoomGrain>(_observedRoomId);
            await room.Unsubscribe(observer);
        }
    }

    private async Task Reserve(string timeSlotId)
    {
        using var _ = ActivityScope.Create(nameof(Reserve));

        await ClearSelected();

        var timeSlot = ClusterClient.GetGrain<ITimeSlotGrain>(timeSlotId);
        var reservation = await timeSlot.Reserve();

        if (!reservation.Success)
        {
            ToastService.ShowError("Reservation failed.");
            return;
        }

        _reservation = reservation;
        _reservationTimer = new Timer(TickReservationTimer, null, 0, 1000);
    }

    private async Task CancelReservation()
    {
        using var _ = ActivityScope.Create(nameof(CancelReservation));

        if (_reservation is null)
        {
            return;
        }

        var timeSlot = ClusterClient.GetGrain<ITimeSlotGrain>(_reservation.TimeSlotId);
        var success = await timeSlot.CancelReservation(_reservation.ReservationId!);

        if (success)
        {
            ToastService.ShowSuccess("Reservation cancelled");
        }
        else
        {
            ToastService.ShowError("Unable to cancel reservation");
        }

        _reservation = null;
        await ClearSelected();
    }

    private async Task CompleteBooking()
    {
        using var _ = ActivityScope.Create(nameof(CompleteBooking));

        if (_reservation is null)
        {
            return;
        }

        var timeSlot = ClusterClient.GetGrain<ITimeSlotGrain>(_reservation.TimeSlotId);
        var success = await timeSlot.Book(_reservation.ReservationId!);

        if (success)
        {
            ToastService.ShowSuccess("Booking completed");
        }
        else
        {
            ToastService.ShowError("Unable to complete booking");
        }

        _reservation = null;
        await ClearSelected();
    }

    private async Task ClearSelected()
    {
        if (_reservationTimer is not null)
        {
            await _reservationTimer.DisposeAsync();
            _reservationTimer = null;
        }

        if (_reservation is not null)
        {
            var timeSlot = ClusterClient.GetGrain<ITimeSlotGrain>(_reservation.TimeSlotId);
            await timeSlot.CancelReservation(_reservation.ReservationId!);
            _reservation = null;
        }
    }

    public async Task OnReservationExpired()
    {
        ToastService.ShowWarning("Reservation expired");

        _reservation = null;
        await ClearSelected();
        await InvokeAsync(StateHasChanged);
    }

    public async Task OnAvailabilityChanged(TimeSlot timeSlot)
    {
        if (timeSlot.Date != DateOnly.FromDateTime(_inputModel.Date))
        {
            return;
        }

        _timeSlots = _timeSlots
            .Select(x => x.Id == timeSlot.Id ? timeSlot : x)
            .ToArray();

        await InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        if (_roomObserverTimer is not null)
        {
            await _roomObserverTimer.DisposeAsync();
        }

        if (_reservationTimer is not null)
        {
            await _reservationTimer.DisposeAsync();
        }

        // Stop observing room.
        if (_observedRoomId is not null)
        {
            var room = ClusterClient.GetGrain<IRoomGrain>(_observedRoomId);
            var observer = ClusterClient.CreateObjectReference<IRoomObserver>(this);
            await room.Unsubscribe(observer);
        }
    }

    private async void ResubscribeToRoom(object? _)
    {
        // Resubscribe to room periodically, as observers are not persisted.
        if (_observedRoomId is not null)
        {
            var room = ClusterClient.GetGrain<IRoomGrain>(_observedRoomId);
            var observer = ClusterClient.CreateObjectReference<IRoomObserver>(this);
            await room.Subscribe(observer);
        }
    }

    private async void TickReservationTimer(object? _)
    {
        if (_reservation?.ExpiresOn <= DateTimeOffset.UtcNow)
        {
            await OnReservationExpired();
        }

        await InvokeAsync(StateHasChanged);
    }

}